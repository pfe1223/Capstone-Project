I came across an article today on Hacker News about why coding is so hard to learn. As I can sympathize with the title, I thought I would give the article a quick look. To me at least, this article is an example as to why we are stuck with such an obtuse subject. First, learning to code is hard. I do not want to deny this point. Some of this is due to the fact that certain concepts are hard to comprehend in and of themselves. Other difficulties exist because of the choices the programming community did or did not make over the years.

Seymour Papert describes something called the QWERTY problem. When typewriters were first invented, the mechanical underpinnings were crude. The arms would get tangled up in themselves. To fix this, the keyboard layout was changed to QWERTY so that the most commonly used letters were spaced further apart. This reduced the number of times the arms would get tangled. Over time, the mechanics improved such that typewriters would not jam as often. Today, computer keyboards do not suffer the fate of jamming due to key layout. However, we have kept the QWERTY configuration because that is the way we have always done things. You can ascribe this to laziness or nostalgia, but it remains that the keyboards we use were not designed to maximize productivity.

This, I feel, is a pretty good description of programming in general. Many of the same practices that started at the dawn of programming are with us still today. The reasons for this are more complex than that of the typewriter. If you are interested, Bret Victor gave an interesting talk describing how programming evolved. A former professor of mine told the class that nothing is natural, it is only historical. That is, if the way something is done remains unchanged for long enough, then we ascribe some sort of natural order to it. Changing the way things are done would tantamount to going against the laws of nature.

Regarding the aforementioned article, the author lays out a progression of how an individual typically becomes a programmer. It is a roller coaster affair. The first stage is Hand Holding, the second is the Cliff of Confusion, the third is the Desert of Despair, and the fourth is the Upswing of Awesome. At the end, you will be job ready programmer (at least that is what the graphics say). The Cliff of Confusion gets its name from the fact that, once you graduate from using a service like Code Academy, the information available to novice programmers is overwhelming. Moreover, the scope of the information goes well beyond that of the hand holding stage. Notice, the problem is not the system of learning how to program. What has always been done is still sufficient. It is just that now the amount of information at our fingertips (thanks a lot Google!) and the scope of the information is too much. Bret Victor and Doug Engelbart would disagree.

The author takes a similar approach to the Desert of Despair. This is a period of self-doubt, frustration, and the like. The author says that only perseverance will get you through this time. Again, no critical thought is given to the circumstance around the state of programming. Good ol' elbow grease and intestinal fortitude are good enough. The article ends with some suggestions for making the transition to a job-ready programmer easier. I have no doubt that these suggestions will make a positive difference. However, what more can we gain if we adopt Victor's point of view? Why not reconstruct the way in which we learn to program? After all, there is nothing natural about the way we constructed how we learn to program. It is only historical. There needs to be another approach, one free from nostalgia. I hope this capstone can better realize the works of Papert, Engelbart, and Victor as a teaching aid for the Elm language.